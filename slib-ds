# slib.py
import cv2
import numpy as np
from tflite_runtime.interpreter import Interpreter

class ShipDetector:
    def __init__(self, TF_LITE_MODEL, LABEL_MAP, THRESHOLD):
        self.TF_LITE_MODEL = TF_LITE_MODEL
        self.LABEL_MAP = LABEL_MAP
        self.THRESHOLD = THRESHOLD
        self.interpreter = Interpreter(model_path=TF_LITE_MODEL)
        self.interpreter.allocate_tensors()
        self.input_details = self.interpreter.get_input_details()
        self.output_details = self.interpreter.get_output_details()
        _, self.INPUT_HEIGHT, self.INPUT_WIDTH, _ = self.input_details[0]['shape']
        with open(LABEL_MAP, 'r') as f:
            self.labels = [line.strip() for line in f.readlines()]

    def process(self, frame):
        original_height, original_width = frame.shape[:2]
        pad = abs(original_width - original_height) // 2
        x_pad = pad if original_height > original_width else 0
        y_pad = pad if original_width > original_height else 0
        frame_padded = cv2.copyMakeBorder(frame, y_pad, y_pad, x_pad, x_pad, cv2.BORDER_CONSTANT, (0,0,0))
        padded_height, padded_width = frame_padded.shape[:2]

        frame_rgb = cv2.cvtColor(frame_padded, cv2.COLOR_BGR2RGB)
        frame_resized = cv2.resize(frame_rgb, (self.INPUT_WIDTH, self.INPUT_HEIGHT))
        input_data = np.expand_dims(frame_resized, axis=0).astype(np.uint8)

        self.interpreter.set_tensor(self.input_details[0]['index'], input_data)
        self.interpreter.invoke()

        boxes = self.interpreter.get_tensor(self.output_details[0]['index'])[0]
        classes = self.interpreter.get_tensor(self.output_details[1]['index'])[0]
        scores = self.interpreter.get_tensor(self.output_details[2]['index'])[0]

        detections = []
        for score, box, class_id in zip(scores, boxes, classes):
            if score < self.THRESHOLD or self.labels[int(class_id)] != 'boat':
                continue

            y1 = int(max(0, (box[0] * padded_height) - y_pad))
            x1 = int(max(0, (box[1] * padded_width) - x_pad))
            y2 = int(min(original_height, (box[2] * padded_height) - y_pad))
            x2 = int(min(original_width, (box[3] * padded_width) - x_pad))

            if x2 <= x1 or y2 <= y1:
                continue

            detections.append([x1, y1, x2, y2, score])
        
        return detections if detections else []

class ShipTracker:
    def __init__(self, frame, bbox):
        self.tracker = cv2.TrackerCSRT_create()
        self.bbox = (bbox[0], bbox[1], bbox[2]-bbox[0], bbox[3]-bbox[1])
        self.tracker.init(frame, self.bbox)

    def update(self, frame):
        success, bbox = self.tracker.update(frame)
        if success:
            x, y, w, h = [int(v) for v in bbox]
            return (x, y, x+w, y+h)
        return None

class Painter:
    @staticmethod
    def paint(frame, detections, trackers):
        # Draw detections (green)
        for det in detections:
            x1, y1, x2, y2, _ = det
            cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 255, 0), 2)
        
        # Draw trackers (red)
        for trk in trackers.values():
            x1, y1, x2, y2 = trk
            cv2.rectangle(frame, (x1, y1), (x2, y2), (0, 0, 255), 3)
